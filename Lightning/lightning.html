<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lightning Simulator</title>
    <style>
        html, body { height: 100%; margin: 0; }
        body { background: #000; }
        canvas { position: fixed; inset: 0; width: 100%; height: 100%; display: block; }
    </style>
</head>
<body>
    <canvas id="c"></canvas>
    <script>
        const canvas = document.getElementById("c");
        const ctx = canvas.getContext("2d");

        let W = 0, H = 0;
        let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        let stars = [];

        function resizeCanvas() {
            W = Math.floor(window.innerWidth);
            H = Math.floor(window.innerHeight);

            canvas.width = Math.floor(W * DPR);
            canvas.height = Math.floor(H * DPR);
            canvas.style.width = W + "px";
            canvas.style.height = H + "px";

            ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
            initializeStars();
        }

        function initializeStars() {
            const count = Math.floor((W * H) / 10000);
            stars = Array.from({ length: count }, () => ({
                x: Math.random() * W,
                y: Math.random() * H,
                r: Math.random() * 1.4 + 0.3,
                a: Math.random() * Math.PI * 2,
                s: 0.5 + Math.random() * 0.5
            }));
        }

        resizeCanvas();
        window.addEventListener("resize", resizeCanvas);

        function randomFloat(min, max) {
            return min + Math.random() * (max - min);
        }

        function randomInt(min, max) {
            return Math.floor(min + Math.random() * (max - min));
        }

        const bolts = [];
        let flashIntensity = 0;
        let nextSpawnTime = 0;

        function drawBackground() {
            ctx.globalCompositeOperation = "source-over";
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, W, H);

            const gradient = ctx.createRadialGradient(W / 2, H * 0.28, 0, W / 2, H * 0.28, Math.hypot(W, H));

            gradient.addColorStop(0, "rgba(30, 80, 160, 0.35)");
            gradient.addColorStop(0.5, "rgba(12, 30, 60, 0.15)");
            gradient.addColorStop(1, "rgba(0, 0, 0, 0)");

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, W, H);
        }

        function drawStars(time) {
            ctx.globalCompositeOperation = "source-over";

            for (const star of stars) {
                const alpha = 0.5 + 0.5 * Math.sin(time * 0.001 * star.s + star.a);
                ctx.fillStyle = "rgba(255, 255, 255," + (0.3 + 0.7 * alpha) + ")";
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.r, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function createBolt(startX, startY, endX, endY, branchDepth) {
            const points = [{ x: startX, y: startY }];
            const maxSegments = randomInt(18, 32);

            let x = startX, y = startY;

            const stepX = (endX - startX) / maxSegments;
            const stepY = Math.max(8, (endY - startY) / maxSegments);

            let spread = randomFloat(18, 40);

            for (let i = 0; i < maxSegments; i++) {
                x += stepX + randomFloat(-spread, spread);
                y += stepY + randomFloat(-6, 6);
                
                points.push({ x, y });
                
                if (branchDepth > 0 && Math.random() < 0.18) {
                    const forkLength = randomInt(8, 16);
                    let fx = x, fy = y;
                    let forkSpread = spread * 0.6;
                    const forkPoints = [{ x: fx, y: fy }];

                    for (let k = 0; k < forkLength; k++) {
                        fx += stepX * 0.2 + randomFloat(-forkSpread, forkSpread);
                        fy += Math.max(6, stepY * 0.8) + randomFloat(-6, 6);
                        forkPoints.push({ x: fx, y: fy});
                    }

                    bolts.push({ pts: forkPoints, life: 1, widthScale: randomFloat(0.4, 0.7), glow: randomFloat(8, 16) });
                }

                if (spread > 6) {
                    spread *= 0.96;
                }
            }

            bolts.push({
                pts: points,
                life: 1,
                widthScale: randomFloat(0.6, 1),
                glow: randomFloat(12, 22)
            });
        }

        function spawnRandomBolt() {
            const startX = randomFloat(0, W);
            const startY = randomFloat(-60, 80);
            const endX = startX + randomFloat(-W * 0.25, W * 0.25);
            const endY = randomFloat(H * 0.7, H * 0.95);
            createBolt(startX, startY, endX, endY, 2);

            for (let i = 0; i < randomInt(1, 3); i++) {
                createBolt(
                    startX + randomFloat(-80, 80),
                    startY + randomFloat(-40, 40),
                    endX + randomFloat(-120, 120),
                    endY,
                    randomInt(1, 2)
                );
            }

            flashIntensity = Math.max(flashIntensity, randomFloat(0.35, 0.65));
        }

        function drawBolt(bolt) {
            if (bolt.life <= 0.02) {
                return;
            }

            ctx.lineJoin = "round";
            ctx.lineCap = "round";
            ctx.globalCompositeOperation = "screen";
            ctx.shadowBlur = bolt.glow;
            ctx.shadowColor = "rgba(140, 190, 255," + (0.7 * bolt.life) + ")";
            ctx.strokeStyle = "rgba(120, 180, 255," + (0.6 * bolt.life) + ")";
            ctx.lineWidth = 3 * bolt.widthScale;

            ctx.beginPath();
            ctx.moveTo(bolt.pts[0].x, bolt.pts[0].y);

            for (let i = 1; i < bolt.pts.length; i++) {
                ctx.lineTo(bolt.pts[i].x, bolt.pts[i].y);
            }

            ctx.stroke();

            ctx.shadowBlur = 0;
            ctx.strokeStyle = "rgba(255, 255, 255," + (0.95 * bolt.life) + ")";
            ctx.lineWidth = 1.2 * bolt.widthScale;

            ctx.beginPath();
            ctx.moveTo(bolt.pts[0].x, bolt.pts[0].y);
            
            for (let i = 1; i < bolt.pts.length; i++) {
                ctx.lineTo(bolt.pts[i].x, bolt.pts[i].y);
            }

            ctx.stroke();
            ctx.globalCompositeOperation = "source-over";
            bolt.life *= 0.88;
        }

        function drawFlashOverlay() {
            if (flashIntensity > 0.001) {
                ctx.globalCompositeOperation = "screen";
                ctx.fillStyle = "rgba(255, 255, 255," + flashIntensity + ")";
                ctx.fillRect(0, 0, W, H);
                ctx.globalCompositeOperation = "source-over";
                flashIntensity *= 0.8;
            }
        }

        function animationLoop(time) {
            drawBackground();
            drawStars(time);

            for (let i = bolts.length - 1; i >= 0; i--) {
                const bolt = bolts[i];
                drawBolt(bolt);
                if (bolt.life <= 0.02) {
                    bolts.splice(i, 1);
                }
            }

            drawFlashOverlay();

            if (time >= nextSpawnTime) {
                const bursts = randomInt(1, 3);
                for (let i = 0; i < bursts; i++) {
                    spawnRandomBolt();
                }
                nextSpawnTime = time + randomFloat(700, 2400);
            }
            requestAnimationFrame(animationLoop);
        }

        requestAnimationFrame(animationLoop);
    </script>
</body>
</html>